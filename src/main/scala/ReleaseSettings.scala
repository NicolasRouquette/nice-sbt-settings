/* ## Release process

   This module defines some new release steps and defines
   a configurable sequence of the release process
*/
package ohnosequences.sbt.nice

import sbt._
import Keys._
import sbt.Extracted._

import sbtrelease._, ReleasePlugin.autoImport._, ReleaseKeys._, ReleaseStateTransformations._

import DocumentationSettings._

import ohnosequences.sbt.SbtGithubReleasePlugin._
import ohnosequences.sbt.SbtGithubReleasePlugin.autoImport._

import laughedelic.literator.plugin.LiteratorPlugin.autoImport._

import com.markatta.sbttaglist._
import TagListPlugin._

import com.timushev.sbt.updates.UpdatesKeys


case object ReleaseSettings extends sbt.AutoPlugin {

  override def trigger = noTrigger
  override def requires =
    ohnosequences.sbt.nice.DocumentationSettings &&
    ohnosequences.sbt.nice.ResolverSettings &&
    ohnosequences.sbt.nice.ScalaSettings &&
    ohnosequences.sbt.nice.WartRemoverSettings &&
    ohnosequences.sbt.SbtGithubReleasePlugin &&
    sbtrelease.ReleasePlugin

  case object autoImport {

    lazy val releaseStepByStep = settingKey[Boolean]("Defines whether release process will wait for confirmation after each step")
  }
  import autoImport._
  import ReleaseSteps._

  /* ### Settings */
  override lazy val projectSettings: Seq[Setting[_]] = Seq(

    /* By default you want to have full controll over the release process: */
    releaseStepByStep := true,

    releaseTagComment := {organization.value +"/"+ name.value +" v"+ (version in ThisBuild).value},

    /* Adding release notes to the commit message */
    releaseCommitMessage := {
      val log = streams.value.log
      val v = (version in ThisBuild).value
      val note: File = baseDirectory.value / "notes" / (v+".markdown")
      val text: String = IO.read(note)
      "Setting version to " +v+ ":\n\n"+ text
    },

    /* This is a sequence of blocks (see them below) */
    releaseProcess := {
      import ReleaseBlocks._

      constructReleaseProcess(
        ???,
        Seq(
          packAndTest,
          genMdDocs,
          genApiDocs,
          publishArtifacts,
          commitAndTag,
          githubRelease,
          githubPush
        )
      )
    }
  )
}

case object ReleaseBlocks {
  import ReleaseSteps._
  import ReleaseSettings.autoImport._

  /* #### Packaging and running tests

     - try to pack
     - run tests (including release-only)
  */
  val packAndTest = ReleaseBlock("Packaging and running tests", Seq(
    releaseTask(Keys.`package`),
    releaseTask(Keys.test in Test)
  ), transit = true)


  /* #### Generating markdown documentation */
  val genMdDocs = ReleaseBlock("Generating markdown documentation", Seq(cleanAndGenerateDocsAction))


  /* #### Generating api documentation and pushing to gh-pages */
  val genApiDocs = ReleaseBlock("Generating api documentation and pushing to gh-pages", Seq(pushApiDocsToGHPagesAction))


  /* #### Publishing artifacts */
  val publishArtifacts = ReleaseBlock("Publishing artifacts", Seq(releaseTask(publish)))


  /* #### Committing and tagging

     - commit markdown documentation
     - finally set and commit release version
     - make a corresponding git tag
  */
  val commitAndTag = ReleaseBlock("Committing and tagging", Seq(
    { st: State =>
      commitFiles("Autogenerated markdown documentation",
                  (Project.extract(st) get docsOutputDirs): _*)(st)
    },
    setReleaseVersion.action,
    commitReleaseVersion,
    tagRelease.action
  ), transit = true)


  /* #### Publishing release on github

     - push tags
     - publish a Github release (notes and assets)
  */
  val githubRelease = ReleaseBlock("Publishing release on github", Seq(
    { st: State =>
      val vcs = Project.extract(st).get(releaseVcs).
        getOrElse(sys.error("No version control system is set!"))
      vcs.cmd("push", "--tags", vcs.trackingRemote) ! st.log
      st
    },
    releaseTask(releaseOnGithub)
  ))


  /* #### Pushing commits to github */
  val githubPush = ReleaseBlock("Pushing commits to github", Seq(
    { st: State =>
      val vcs = Project.extract(st).get(releaseVcs).
        getOrElse(sys.error("No version control system is set!"))
      vcs.cmd("push", vcs.trackingRemote) ! st.log // pushing default branch
      vcs.cmd("push", vcs.trackingRemote, vcs.currentBranch) ! st.log // and then the current one
      st
    }
  ))
}


case object ReleaseSteps {
  import ReleaseSettings.autoImport._

  // will return None if things go wrong
  def execCommandWithState(vcs: Vcs, cmd: Seq[String], st: State): Option[State] = {

    val exitCode = vcs.cmd(cmd: _*) ! st.log

    if (exitCode == 0) Some(st) else None
  }

  // what's the point of this check??
  def isOk(vcs: Vcs): Boolean = (vcs.status !! ).trim.nonEmpty

  /* ### Additional release steps */

  /* This converts a task key to an action (which is implicitly converted the to a release step) */
  def releaseTask[T](key: TaskKey[T]) = { st: State =>
    val extracted = Project.extract(st)
    val ref = extracted.get(thisProjectRef)
    try {
      extracted.runAggregated(key in ref, st)
    } catch {
      case e: java.lang.Error => sys.error(e.toString)
    }
  }

  /* A generic action for commiting given sequence of files with the given commit message */

  // NOTE: With any VCS business we always assume Git and don't care much about other VCS systems
  def commitFiles(msg: String, files: File*) = { st: State =>

    val extracted = Project.extract(st)
    val vcs = extracted.get(releaseVcs).getOrElse(sys.error("No version control system is set!"))

    def vcsExec(cmd: Seq[String]): Option[State] = execCommandWithState(vcs, cmd, st)

    val base = vcs.baseDir
    /* Making paths relative to the base dir */
    val paths = files map { f => IO.relativize(base, f).
      getOrElse(s"Version file [${f}] is outside of this VCS repository with base directory [${base}]!")
    }
    /* adding files */

    vcsExec( Seq("add", "--all") ++ paths ) flatMap {

      _ => if ( isOk(vcs) ) vcsExec( Seq("commit", "-m", msg) ++ paths) else None

    } getOrElse st
  }

  /* We will need to set the version temporarily during the release (and commit it later in a separate step) */
  lazy val tempSetVersion = { st: State =>
    val v = st.get(versions).getOrElse(sys.error("No versions are set! Was this release part executed before inquireVersions?"))._1
    st.log.info("Setting version temporarily to '" + v + "'")
    ReleaseStateTransformations.reapply(Seq(
      version in ThisBuild := v
    ), st)
  }

  /* Announcing release blocks */
  def shout(what: String, transit: Boolean = false) = { st: State =>
    val extracted = Project.extract(st)
    st.log.info("\n"+what+"\n")
    if (extracted.get(releaseStepByStep) && !transit) {
      SimpleReader.readLine("Do you want to continue (y/n)? [y] ") match {
        case Some("n" | "N") => sys.error("Aborting release")
        case _ => // go on
      }
    }
    st
  }

  /* A release block is a sequence of release steps. We want this to be able
     - to take their checks and run them first
     - to operate on semantic groups of steps
  */
  case class ReleaseBlock(name: String, steps: Seq[ReleaseStep], transit: Boolean = false)

  implicit def blockToCommand(b: ReleaseBlock) = Command.command(b.name){
    (b.steps map { s => s.check andThen s.action }).
      foldLeft(identity: State => State)(_ andThen _)
  }

  /* This function takes a seuqence of release blocks and constructs a normal release process:
     - it aggregates checks from all steps and puts them as a first release block
     - then it runs `action` of every release step, naming release blocks and asking confirmation if needed
  */
  def constructReleaseProcess(checks: ReleaseBlock, blocks: Seq[ReleaseBlock]): Seq[ReleaseStep] = {
    val allChecks = for(
        block <- blocks;
        step <- block.steps
      ) yield ReleaseStep(step.check)

    val initBlock = ReleaseBlock(checks.name, checks.steps ++ allChecks, transit = true)
    val allBlocks = initBlock +: blocks
    val total = allBlocks.length

    for(
      (block, n) <- allBlocks.zipWithIndex: Seq[(ReleaseBlock, Int)];
      heading = s"[${n+1}/${total}] ${block.name}";
      announce = ReleaseStep(shout("\n"+ heading +"\n"+ heading.replaceAll(".", "-") +"\n  ", block.transit));
      step <- announce +: block.steps
    ) yield step
  }

}
